<html>

<body onload="canvas.setup();globalInitialize();">
    <canvas id="canvasArea" style="position: absolute; left: 0; top: 0; z-index: 0; width:100%;height:100%"></canvas>
    <script src="./canvas.js"></script>
</body>

</html>
<script>

    // Declare all global variables here
    var agentsCount = 100;
    var sync = false;
    var timeStep = 1;
    var start = 0;
    var shift = 0;
    var state = 0;
    var divider = [];
    var width;
    var height;
    var agentsList = []; //array to hold obstracle objects
    var globalCounter = 0; //variable that keeps chak of score, score = no. of obstracles passed.
    var limit = Math.tanh(1);
    var indCycle = 6;
    var glowStart = 3;
    var ticksRecall = 0;
    var glowLimit = Math.tanh(glowStart/indCycle);
    var prevCounter = 0;
    var timeLapsed = 0;
    // To initialize the height and width dependent variables adter canvas loads
    function globalInitialize()
    {
        // alert(width)
        width = canvas.width;
        height = canvas.height;
        for(var i = 0; i < agentsCount; i++)
            agentsList.push(new fireFly((width-2)*Math.random(),(height-2)*Math.random(),1,indCycle*Math.random())); //10 depicts average speed
    }

    // Declare custom functions here
    // To handle white rectangles of divider
    class fireFly {
        constructor(x_cord, y_cord, speed, timer){
            this.x_cord = x_cord;
            this.y_cord = y_cord;
            this.speed = speed;
            this.x_speed = this.speed*(Math.random()-0.5);
            this.y_speed = this.speed*(Math.random()-0.5);
            this.timer = timer;
            this.glown = false;
            this.radius = 5;
            this.baseRadius = 5;
            this.glowColor = [0xcc,0xff,0x00];
            this.baseColor = [0x40,0x40,0x40];
            this.curColor = this.baseColor;
        }
        signalRecieve(){
            if(this.timer == 0) 
                return 0;
            var water = Math.tanh(this.timer/indCycle);
            water += 1/(10*agentsList.length);
            water = Math.min(1,water);
            this.timer = Math.min(indCycle*Math.atanh(water),indCycle); 
            if(this.timer == indCycle) {
                this.glow();
                return 1;
            }
            return 0;
        }
        glow(){
            if(Math.tanh(this.timer/indCycle) >= limit) {
                    this.glown = false;
                    this.timer = 0;
                    return 1;   
            }
            if(this.glown == true) {
                var peak = 1/2;
                var glowTimer = this.timer-5;
                var frac = (peak - Math.abs(glowTimer-peak))/peak;
                frac = Math.min(frac,1);
                frac = Math.max(frac,0);
                var glowColor = this.glowColor;
                var baseColor = this.baseColor;
                this.curColor = [(1-frac)*baseColor[0]+frac*glowColor[0],(1-frac)*baseColor[1]+frac*glowColor[1],(1-frac)*baseColor[2]+frac*glowColor[2]];
                this.radius = this.baseRadius+frac*0.5*this.baseRadius;
            }
            else if(Math.tanh(this.timer/indCycle) >= glowLimit) { //Essentially every six seconds
                this.glown = true;
            }
            else {
                this.glowTimer = 0;
                this.curColor = this.baseColor;
            }
            this.timer += 10e-3/timeStep;
            return 0;
        }
        move(){
            if(this.x_cord+this.radius >= width || this.x_cord-this.radius <= 0) {
                if(this.x_speed > 0)
                    this.x_speed = -1*this.speed*Math.random();
                else
                    this.x_speed = this.speed*Math.random();
                this.x_cord = Math.min(this.x_cord, width-this.radius);
                this.x_cord = Math.max(this.x_cord, this.radius);
            }
            if(this.y_cord+this.radius >= height || this.y_cord-this.radius <= 0) {
                if(this.y_speed > 0)
                    this.y_speed = -1*this.speed*Math.random();
                else
                    this.y_speed = this.speed*Math.random();
                this.y_cord = Math.min(this.y_cord, height-this.radius);
                this.y_cord = Math.max(this.y_cord, this.radius);
            }
            // canvas.setDrawMode("stroke");
            // canvas.drawCircle(this.x_cord,this.y_cord,this.radius);
            canvas.setDrawMode("fill");
            var color = this.curColor;
            canvas.setColor("rgb("+color[0].toString()+","+color[1].toString()+","+color[2].toString()+")")
            canvas.drawCircle(this.x_cord,this.y_cord,this.radius);
            this.x_cord += this.x_speed;
            this.y_cord += this.y_speed;
        }
        TimeStep(){
            return this.timer;
        }
    }
    //Car instance to capsulate it's dimensions and methods.
    function main() {
        globalCounter += (10e-3/timeStep);
        canvas.clear();
        canvas.setDrawMode("fill");
        canvas.setColor("black");
        canvas.drawRectangle(0,0,width,height);
        var tickedAgents = [];
        for(var i = 0; i < agentsCount; i++) {
            if(agentsList[i].glow()) {
                tickedAgents.push(i);
            }
            agentsList[i].move();
        }
        var ticks = tickedAgents.length;
    
        
        if(ticks == agentsList.length && sync == false) {
            window.alert("Sync emerged!");
            sync = true;
        }
        canvas.setDrawMode("fill");
        canvas.setColor("white");
        canvas.drawText(0, 20, "Last unison:"+ticksRecall.toString(), fontSize = 20) // Draws <message> at (x, y)
        // canvas.drawText(0, 40, "Time since unison:"+timeLapsed.toString().slice(0,4)+"sec", fontSize = 20) // Draws <message> at (x, y)
        if(ticks > 0) {
            timeLapsed = globalCounter - prevCounter;
            prevCounter = globalCounter;
            ticksRecall = ticks;
            var ind = 0;
            var hits = ticks;
            for(var i = 0; i < agentsList.length; i++) {
                if(ind < ticks && i == tickedAgents[ind]) 
                    ind += 1;
                else {
                    for(var j = 0; j < hits; j++) {
                        agentsList[i].signalRecieve();
                    }
                }
            }
        }


        // console.log(agentsList[0]);
        // canvas.setColor("green");
        // canvas.drawRectangle(0,0,width,height);
        // canvas.setColor("grey");
        // canvas.drawRectangle(width/2-width/8,0,width/4,height);
        // canvas.setColor("white");
        // canvas.drawText(width/8-width/128,7*height/16-height/32,"Traffic",height/8);
        // canvas.drawText(width/8+width/128,9*height/16-height/32,"Rush",height/8);
        // canvas.drawText(width/32,20*height/32,"Use left and right arrow keys to move avoid collision",height/32);
        // canvas.drawText(24*width/32,height/2-height/16,"Score",3*height/32);
        // canvas.drawText(51*width/64,height/2+height/16,score,height/8);
        // //before obstracles start to begin move the player car ahead
        // if(player_car.y_pos() > 7*height/12)
        // {
        //     for (var i = 0; i < 5 ; i++)
        //         divider[i].hault(1);
        //     player_car.hault(0);
        //     for (var i = 0; i < 5 ; i++)
        //         divider[i].move();
        // }
        // //once obstracles start move the divider and put player car static
        // else
        // {
        //     for(var i = 0 ; i < opp_car.length ; i++)
        //     {
        //         if(player_car.clash(opp_car[i]))
        //         {
        //             gameover = 1;
        //             break;
        //         }
        //     }
        //     for (var i = 0; i < 5; i++)
        //         divider[i].hault(gameover);
        //     for (var i = 0; i < opp_car.length; i++)
        //         opp_car[i].hault(gameover);
        //     player_car.hault(1);
        //     for (var i = 0; i < 5 ; i++)
        //         divider[i].move();
        //     for(var i = 0 ; i < opp_car.length; i++)
        //     {
        //         if(opp_car[i].y_pos() > height)
        //             opp_car.shift();
        //     }     
        //     for (var i = 0; i < opp_car.length; i++)
        //     {
        //         if(opp_car[i].y_pos() > 7*height/12 + height/6 && opp_car[i].check_crossed() == 0)
        //         {
        //             opp_car[i].set_crossed();
        //             score++;
        //         }
        //         opp_car[i].move_y();
        //     }
        //     if(opp_car.length == 0 || opp_car[opp_car.length-1].y_pos() >= gap)
        //     {
        //         var random_x = Math.floor(Math.random()*8)+2;
        //         opp_car.push(new Car(3*width/8+random_x*(width/64),-height/6,0,height/64+height/2048*score,"#8B008B","#EE82EE"));
        //         gap = gap-height/512;
        //     }
        //     if(gameover == 1)
        //     {
        //         canvas.setColor('red');
        //         canvas.setDrawMode('fill');
        //         canvas.drawText(width/2-width/16,height/2-height/32,"Game Over",height/16)
        //     }
        // }
        // player_car.move_y();
    }
    // Override functions here; 
    canvas.mainFunction = main;
    //for left an right motion of car
	// canvas.keyDownCallback = function(e) {
	// 	if (e.which == 37) {
	// 		player_car.move_x(0);
	// 	} else if (e.which === 39) {
    //         player_car.move_x(1);
	// 	}
	// };
    //Main function is called every <timestep> milliseconds as per below timeStep
    canvas.startMain(timeStep);
</script>